---
authors: "T1 - Phoenix"
title: "Spotify Tracks Popularity Prediction"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries Used, warning=FALSE, include=FALSE}
library(tidyverse)
library(dplyr)
library(corrplot)
library(mapview)
library(tigris)
library(sf)
library(ggplot2)
library(lubridate)
library(ezids)
library(gridExtra)
library(grid)
library(lattice)
library(caret)
```

# Introduction

1. Introduction
2. Data Pre-Processing
3. EDA
4. Models
5. Conclusion



Let us pull the dataset from the file `spotify_dataset.csv` into a dataframe `df_spotify`. As this file is huge in size, we cannot upload it on GitHub. Thus, we are storing the file in a folder called `spotify_dataset` that is located in one folder above the project folder.

```{r Pulling the Data}
df_spotify <- data.frame(read.csv('spotify_dataset.csv'))
str(df_spotify)
```

```{r}
head(df_spotify)
tail(df_spotify)
```

```{r}
summary(df_spotify)
```

First, let's check the percentage of NA's present in each columns of the dataset.

```{r Checking NAs}
(colMeans(is.na(df_spotify)))*100
```

```{r}
data_corr<-df_spotify %>% select_if(is.numeric)   
data_corr = subset(data_corr, select = -c(X) )

corrplot(cor(data_corr),
         type = "upper",
         col = colorRampPalette(c("white", "deepskyblue", "blue4"))(100),
         is.corr = TRUE,
         order = "hclust",
         tl.col = "black",
         diag = TRUE)
```



```{r Popularity Distribution Graph}
popHist <- ggplot(df_spotify, aes(x=popularity)) + geom_histogram(color="black", fill="steelblue1", alpha=0.9, bins = 101)+
  ggtitle("Histogram of Popularity")
popHist
```


```{r, results='hide'}
# made basic histogram & scatterplot for every other variables that we didn't include to our SMART Q

danceHist <- ggplot(df_spotify, aes(x=danceability)) + geom_histogram(color="black", fill="steelblue1", alpha=0.9, bins = 150)+
  ggtitle("Histogram of Danceability")
danceHist

danceSct<- ggplot(df_spotify, aes(x=popularity, y= danceability)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for Danceability")
danceSct

acHist <- ggplot(df_spotify, aes(x=acousticness)) + geom_histogram(color="black", fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of Acousticness")
acHist

acSct<- ggplot(df_spotify, aes(x=popularity, y= acousticness)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for Acousticness")
acSct

energyHist <- ggplot(df_spotify, aes(x=energy)) + geom_histogram(color="black", fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of Energy")
energyHist

energySct<- ggplot(df_spotify, aes(x=popularity, y= energy)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for Energy")
energySct

speechinessHist <- ggplot(df_spotify, aes(x=speechiness)) + geom_histogram(color="black", fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of speechiness")
speechinessHist

speechinessSct<- ggplot(df_spotify, aes(x=popularity, y= speechiness)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for speechiness")
speechinessSct

instrumentalnessHist <- ggplot(df_spotify, aes(x=instrumentalness)) + geom_histogram(color="black",fill="steelblue1", alpha=0.9, bins = 50)+
  ggtitle("Histogram of instrumentalness")
instrumentalnessHist

instrumentalnessSctr<- ggplot(df_spotify, aes(x=popularity, y= instrumentalness)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for instrumentalness")
instrumentalnessSctr

livenessHist <- ggplot(df_spotify, aes(x=liveness)) + geom_histogram(color="black",fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of liveness")
livenessHist

livenessSct<- ggplot(df_spotify, aes(x=popularity, y= liveness)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for liveness")
livenessSct

valenceHist <- ggplot(df_spotify, aes(x=valence)) + geom_histogram(color="black",fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of valence")
valenceHist

valenceSctr<- ggplot(df_spotify, aes(x=popularity, y= valence)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for valence")
valenceSctr

tempoHist <- ggplot(df_spotify, aes(x=tempo)) + geom_histogram(color="black",fill="steelblue1", alpha=0.9, bins = 100)+
  ggtitle("Histogram of tempo")
tempoHist

tempoSctr<- ggplot(df_spotify, aes(x=popularity, y= tempo)) +
  geom_point(colour="steelblue1",size = 0.1) +
  ggtitle("Scatterplot for tempo")
tempoSctr
```

```{r}
library("ggpubr")
histfig <- ggarrange(danceHist,acHist,energyHist, speechinessHist, instrumentalnessHist,livenessHist, valenceHist,tempoHist, ncol = 3, nrow = 2)
histfig

sctfig <- ggarrange(danceSct, acSct,energySct, speechinessSct, instrumentalnessSctr,livenessSct, valenceSctr,tempoSctr, ncol = 3, nrow = 2)
sctfig
```


#DATA Preprocessing
```{r}
options(dplyr.summarise.inform = FALSE)
missing.values <- df_spotify %>%
    gather(key = "key", value = "val") %>%
    mutate(is.missing = is.na(val)) %>%
    group_by(key, is.missing) %>%
    summarise(num.missing = n()) %>%
    filter(is.missing==T) %>%
    select(-is.missing) %>%
    arrange(desc(num.missing)) 

missing.values
```

```{r}
df_spotify<-df_spotify %>%
 mutate(duration_min = duration_ms/60000)

df_spotify$duration_min <- round(df_spotify$duration_min ,digit=2)
head(df_spotify)
```

```{r}
df_spotify$artists[df_spotify$artists == '['] <- ''
df_spotify$artists[df_spotify$artists == ']']<- ''
df_spotify$artists[df_spotify$artists == "'"]<- ''
head(df_spotify)
```

# removing columns track_id and X as they are not required.


```{r}
df_spotify<-df_spotify %>%
 mutate(duration_min = duration_ms/60000)

df_spotify$duration_min <- round(df_spotify$duration_min ,digit=2)
head(df_spotify)
```



```{r}
data_corr<-df_spotify[!duplicated(df_spotify),]
```




```{r}
data_corr = subset(data_corr, select = -c(track_id,X,artists,album_name,track_name,explicit,track_genre,duration_ms) )
```



```{r}
valence <- ggplot(data_corr, aes(x=valence)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

tempo <- ggplot(data_corr, aes(x=tempo)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

acousticness <- ggplot(data_corr, aes(x=acousticness)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

danceability <- ggplot(data_corr, aes(x=danceability)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

speechiness <- ggplot(data_corr, aes(x=speechiness)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

mode <- ggplot(data_corr, aes(x=mode)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

liveness <- ggplot(data_corr, aes(x=liveness)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

loudness <- ggplot(data_corr, aes(x=loudness)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

popularity <- ggplot(data_corr, aes(x=popularity)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

energy <- ggplot(data_corr, aes(x=energy)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")


key <- ggplot(data_corr, aes(x=key)) + 
    geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
                   binwidth=.5,
                   colour="steelblue1", fill="white") +
    geom_density(alpha=.2, fill="steelblue1")

```


```{r}
library(ggpubr)
figure <- ggarrange(valence, tempo, acousticness,speechiness, danceability,mode,liveness,loudness,popularity,energy, key, ncol = 3, nrow = 5)
annotate_figure(figure, top = text_grob("Density Histogram for all variables", 
               color = "black", face = "bold", size = 14))
```

#From the distribution plot, we can observe that, columns such as energy, and valence has high variability where as liveness, danceability, tempo and loudness has relatively lower variability and concentrated in some ranges.


```{r}
ggplot(data_corr, aes(x=energy, y=popularity)) + geom_point(col = "steelblue1") 
ggplot(data_corr, aes(x=acousticness, y=popularity)) + geom_point(col = "steelblue1") 
ggplot(data_corr, aes(x=loudness, y=popularity)) + geom_point(col = "steelblue1")
```

```{r}
data_corr <- data_corr %>% mutate(popularity_t = if_else(popularity > 50, 1, 0))
data_corr
```
```{r}
ggplot(data_corr, aes(x = popularity_t, fill=popularity_t)) +
    geom_bar(color="black",fill=c("steelblue3", "blue4"))+
  ggtitle("Popularity_t Distribution")
```




```{r t test on popularity_t with numeric variables}
pop1 <- subset(data_corr, popularity_t == 1)
pop2 <- subset(data_corr, popularity_t == 0)
str(pop1)
str(pop2)

ttest_dance <- t.test(pop1$danceability, pop2$danceability)
ttest_dance
ttest_energy <- t.test(pop1$energy, pop2$energy)
ttest_energy
ttest_loudness <- t.test(pop1$loudness, pop2$loudness)
ttest_loudness
ttest_speechiness <- t.test(pop1$speechiness, pop2$speechiness)
ttest_speechiness
ttest_acousticness <- t.test(pop1$acousticness, pop2$acousticness)
ttest_acousticness
ttest_instrumentalness <- t.test(pop1$instrumentalness, pop2$instrumentalness)
ttest_instrumentalness
ttest_liveness <- t.test(pop1$liveness, pop2$liveness)
ttest_liveness
ttest_valence <- t.test(pop1$valence, pop2$valence)
ttest_valence
ttest_tempo <- t.test(pop1$tempo, pop2$tempo)
ttest_tempo
ttest_duration_ms <- t.test(pop1$duration_ms, pop2$duration_ms)
ttest_duration_ms

```

<<<<<<< Updated upstream
After created the popularity_t column, we split data into two based on the popularity_t. We would like to see the differences on means of numerical variables between two groups. 
H0: The means of numerical variables will be same between different Popularity levels.
H1: The means of numerical variables will NOT be same between different Popularity levels.
Except for the valence and energy, the means of other variables from the popular songs and less popular song were different since the p-values are small enough. Therefore we can conclude that numerical variables except for valence and energy affect the popularity. 

```{r boxplots for variables}
=======
```{r boxplots for variables}
str(data_corr)
>>>>>>> Stashed changes
unique(data_corr$popularity_t)
poptfactor <- data_corr
poptfactor$popularity_t <- as.factor(data_corr$popularity_t)

boxt <- ggplot(poptfactor, aes(x=popularity_t, y=tempo,fill=popularity_t)) + 
<<<<<<< Updated upstream
  geom_boxplot() +
  ggtitle("boxplot for tempo")

boxdu <-ggplot(poptfactor, aes(x=popularity_t, y=duration_ms,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for duration_ms")

boxv <-ggplot(poptfactor, aes(x=popularity_t, y=valence,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for valence")

boxi <-ggplot(poptfactor, aes(x=popularity_t, y=instrumentalness,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for instrumentalness")

boxa <-ggplot(poptfactor, aes(x=popularity_t, y=acousticness,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for acousticness")

boxda <-ggplot(poptfactor, aes(x=popularity_t, y=danceability,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for danceability")

boxe <-ggplot(poptfactor, aes(x=popularity_t, y=energy,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for energy")

boxlo <-ggplot(poptfactor, aes(x=popularity_t, y=loudness,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for loudness")
=======
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for tempo")

#boxdu <-ggplot(poptfactor, aes(x=popularity_t, y=duration_ms,fill=popularity_t)) + 
#  geom_boxplot() +
#  ggtitle("boxplot for duration_ms")

boxv <-ggplot(poptfactor, aes(x=popularity_t, y=valence,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for valence")

boxi <-ggplot(poptfactor, aes(x=popularity_t, y=instrumentalness,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for instrumentalness")

boxa <-ggplot(poptfactor, aes(x=popularity_t, y=acousticness,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for acousticness")

boxda <-ggplot(poptfactor, aes(x=popularity_t, y=danceability,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for danceability")

boxe <-ggplot(poptfactor, aes(x=popularity_t, y=energy,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for energy")

boxlo <-ggplot(poptfactor, aes(x=popularity_t, y=loudness,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for loudness")

boxs <-ggplot(poptfactor, aes(x=popularity_t, y=speechiness,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for speechiness")

boxli <-ggplot(poptfactor, aes(x=popularity_t, y=liveness,fill=popularity_t)) + 
  geom_boxplot(col="black", fill=c("steelblue1","blue4")) +
  ggtitle("boxplot for liveness")

```

```{r}
library("ggpubr")
boxforvar <- ggarrange(boxt, boxv,boxi,boxa,boxda,boxe,boxlo,boxs, boxli, ncol = 3, nrow = 4)
boxforvar
```
```{r}
boxt
boxv
boxi
boxa
boxda
boxe
boxlo
boxs
boxli
# boxplots
```

```{r chisq on pop_t and categorical}
>>>>>>> Stashed changes

boxs <-ggplot(poptfactor, aes(x=popularity_t, y=speechiness,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for speechiness")

boxli <-ggplot(poptfactor, aes(x=popularity_t, y=liveness,fill=popularity_t)) + 
  geom_boxplot() +
  ggtitle("boxplot for liveness")

```

```{r}
boxforvar <- ggarrange(boxt, boxdu, boxv,boxi,boxa,boxda,boxe,boxlo,boxs, boxli, ncol = 3, nrow = 4)
boxforvar
```

```{r chisq on pop_t and categorical}
chi_key <- chisq.test(table(data_corr$popularity_t, data_corr$key))
chi_key
chi_mode <- chisq.test(table(data_corr$popularity_t, data_corr$mode))
chi_mode
chi_time_signature <- chisq.test(table(data_corr$popularity_t, data_corr$time_signature))
chi_time_signature
```

```{r t test and ANOVA on popularity by categorical variables}
unique(pop1$key)
unique(pop1$mode)
unique(pop1$time_signature)
mode1 <- subset(data_corr, mode == 1)
mode0 <- subset(data_corr, mode == 0)
str(mode1)
str(mode0)

ttest_mode <- t.test(mode1$popularity, mode0$popularity)
ttest_mode

aovtime_signature <- aov(popularity ~ time_signature, data = data_corr)
summary(aovtime_signature)
```






#feautre Selection

```{r}
library("leaps")
reg2.best <- regsubsets(popularity_t~. , data = data_corr, nvmax = 12, nbest = 3, method = "exhaustive") 
plot(reg2.best, scale = "Cp", main = "Cp")
```



# Model Building
# Spliting the data





```{r}
set.seed(123)
dat.d <- sample(1:nrow(data_corr),size=nrow(data_corr)*0.8,replace = FALSE) #random selection of 70% data.

data_corr.a = subset(data_corr, select = c(popularity_t,acousticness,danceability,duration_min,energy,instrumentalness
                                           ,liveness,mode,loudness,tempo,valence,key) )
 
 
train <- data_corr.a[dat.d,] # 80% training data
test <- data_corr.a[-dat.d,] # remaining 20% test data
```

# KNN

# Labels for knn
```{r}
library(class)
prc_train_labels <- train[,1]
prc_test_labels<- test[,1]
```


### Selecting the correct "k"
How does "k" affect classification accuracy? Let's create a function to calculate classification accuracy based on the number of "k."
```{r}
chooseK = function(k, train_set, val_set, train_class, val_class){
  
  # Build knn with k neighbors considered.
  set.seed(1)
  class_knn = knn(train = train_set,    #<- training set cases
                  test = val_set,       #<- test set cases
                  cl = train_class,     #<- category for classification
                  k = k) #,                #<- number of neighbors considered
                  # use.all = TRUE)       #<- control ties between class assignments. If true, all distances equal to the k-th largest are included
  
  tab = table(class_knn, val_class)
  
  # Calculate the accuracy.
  accu = sum(tab[row(tab) == col(tab)]) / sum(tab)                         
  cbind(k = k, accuracy = accu)
}

# The sapply() function plugs in several values into our chooseK function.
# function(x)[function] allows you to apply a series of numbers
# to a function without running a for() loop.
knn_different_k = sapply(seq(3, 15, by = 2),  #<- set k to be odd number from 1 to 21
                         function(x) chooseK(x, 
                                             train_set = train,
                                             val_set = test,
                                             train_class = prc_train_labels,
                                             val_class = prc_test_labels))

# Reformat the results to graph the results.
str(knn_different_k)
knn_different_k = data.frame(k = knn_different_k[1,],
                             accuracy = knn_different_k[2,])

# Plot accuracy vs. k.
# install.packages("ggplot2")
loadPkg("ggplot2")

ggplot(knn_different_k,
       aes(x = k, y = accuracy)) +
  geom_line(color = "steelblue1", size = 1.5) +
  geom_point(size = 3) + 
  labs(title = "accuracy vs k")

```

```{r}
prc_test_pred <- knn(train = train, test = test,cl = prc_train_labels, k=3)
```

```{r}
cm_knn<-confusionMatrix(as.factor(prc_test_labels),as.factor(prc_test_pred))
cm_knn
```

# Decision Tree

```{r}
library(rpart)
library(rpart.plot)

fit <- rpart(popularity_t~., data = train, method = 'class')

summary(fit)

```



```{r}
predict_unseen <-predict(fit, test, type = 'class')
table_mat <- table(test$popularity_t, predict_unseen)
table_mat
```

```{r}
accuracy_Test <- sum(diag(table_mat)) / sum(table_mat)
print(paste('Accuracy for test', accuracy_Test))
cm_dt<-confusionMatrix(as.factor(test$popularity_t),as.factor(predict_unseen))
cm_dt
```


# Logistic Regression Model


# Model 1 with all the feautres

```{r}
model = glm(popularity_t~.,data=train )

summary(model)
```

```{r}

Predicr_value = predict(model,test)                          #predict test value purchased

predict_test_value = ifelse((Predicr_value>0.5),1,0)

                           #See predict value and actual
Compare_values = cbind(predict_test_value,test[,1])
Compare_values = data.frame(Compare_values)
cm_lg<-caret::confusionMatrix(as.factor(Compare_values[,1]),as.factor(Compare_values[,2]))
cm_lg
```

```{r}


model_compare <- data.frame(Model = c('KNN',
                                      'Decision Tree',
                                      'Logistic Regression'),
                            Accuracy = c((cm_knn$overall[1])*100,
                                         (cm_dt$overall[1])*100,
                                         (cm_lg$overall[1])*100))

print(model_compare)

ggplot(aes(x=Model, y=Accuracy), data=model_compare) +
    geom_bar(stat='identity', fill = 'steelblue1') +
    ggtitle('Comparative Accuracy of Models on Cross-Validation Data') +
    xlab('Models') +
    ylab('Overall Accuracy')
```


